#!/usr/bin/env python3
import ffmpeg
import sys
import fcntl
import os
import argparse
import tempfile

parser = argparse.ArgumentParser()
parser.add_argument("infile")
parser.add_argument("outfile")
parser.add_argument("--subtitle_index", type=int)
parser.add_argument("--subtitle_file")
parser.add_argument("--downscale_720p", action='store_true')
parser.add_argument("--test", action='store_true')
parser.add_argument("--target_bitrate", type=int,
        default=2500,
        help='target bitrate in kb/s.')
parser.add_argument("--buffer_duration", type=float,
        default=1,
        help='target buffer duration in seconds, i.e. how long you expect player to buffer.')

parser.add_argument("--hls", action='store_true', help="output HLS playlist, with ts chunks in an {outfile}.ts directory")
parser.add_argument("--probe", action='store_true')
args = parser.parse_args()

infile = args.infile
outfile = args.outfile

# try to work around dumb dual audio files
probe = ffmpeg.probe(infile)
if args.probe:
    import pprint
    pprint.pprint(probe)
    sys.exit(0)
audio_track = 0
audio_count = 0
audio_stream = None
sub_count = 0
sub_track = 0
sub_type = 'text'
found_eng_sub_track = False
# XXX clean up spaghetti logic through here
for stream in probe['streams']:
    # try to select jpn audio over english
    if stream['codec_type'] == 'audio' and 'tags' in stream:
        tags = stream['tags']
        if tags and 'language' in tags and tags['language'] == 'jpn':
            audio_track = audio_count
            audio_stream = stream
        audio_count += 1
    if stream['codec_type'] == 'subtitle':
        # try to select default stream
        if 'disposition' in stream and 'default' in stream['disposition'] and stream['disposition']['default'] == 1:
            sub_track = sub_count
            if stream['codec_name'] == 'dvd_subtitle' or stream['codec_name'] == 'hdmv_pgs_subtitle':
                sub_type = 'dvd'
        # try to select the first english sub track, which at least for these awful
        # cyberpunk rips seems to be the japanese tl track and not the dubtitles.
        # it is unfortunately completely ambiguous though.
        if 'language' in stream['tags'] and stream['tags']['language'] == "eng":
            if not found_eng_sub_track:
                sub_track = sub_count
                found_eng_sub_track = True
                print(f"found first english sub track at {sub_track}", file=sys.stderr)
                if stream['codec_name'] == 'dvd_subtitle' or stream['codec_name'] == 'hdmv_pgs_subtitle':
                    sub_type = 'dvd'
        sub_count += 1

if args.subtitle_index:
    print(f"overriding sub track from {sub_track=} to {args.subtitle_index=}", file=sys.stderr)
    sub_track = args.subtitle_index

print(f"selecting {audio_track=} {audio_stream=}", file=sys.stderr)
print(f"selecting {sub_track=}", file=sys.stderr)

ffin = ffmpeg.input(infile)
ffv = ffin.video.filter('format', 'yuv420p')
if args.downscale_720p:
    ffv = ffv.filter('scale', '1280','-1')

# assume subtitle track matches the audio track
if sub_type == 'text':
    subfile = infile
    if args.subtitle_file:
        subfile = args.subtitle_file

    ffv = ffv.filter('subtitles', filename=subfile, stream_index=sub_track)
else:
    # burn the dvd subs on the image
    subs = ffin[f's:{sub_track}']
    s2r = ffmpeg.filter_multi_output([subs, ffv], 'scale2ref')
    ffv = s2r[1].overlay(s2r[0])

# cap bufsize based on expected buffer duration, so there aren't
# bitrate spikes above it and thus buffer underruns during playback.
bufsize = int(args.target_bitrate * args.buffer_duration)

opts = {
        'c:v': 'libx264',
        # XXX the ffmpeg default somehow likes to drop the encoding to `main`
        # compatability. This sounds benign, but for whatever reason, if AVPro
        # sees a main profile mp4 file it has really awful buffering behavior
        # that interacts badly with cloudflare and really screws up audio
        # syncing.  I can't see any bad effects with forcing high profile now,
        # so just do it.
        'profile:v': 'high',
        'preset': 'fast',
        'tune': 'animation',
        'crf': '22',
        #'b:v': '2500K',
        'maxrate': f"{args.target_bitrate}K",
        # try and cap the bitrate, it'll decrease the crf to compensate
        'bufsize': f"{bufsize}K",
        #'c:a': 'copy', TODO ideally we'd just copy existing AAC
        # but need to modify the ffprobe stuff to detect.
        'c:a': 'aac',
        'b:a': '160k',
        'ac': '2',
        #'f': 'mp4',
        }

if args.hls or os.path.splitext(outfile)[1] == ".m3u8":
    # encode as HLS, a bunch of .ts segment files + .m3u8 playlist.
    # Originaly I thought you'd need to do this to work around AVPro's
    # awful HTTP buffering behavior. However it turns out forcing h264 high profile
    # instead of letting h264 drop to main profile solves all those issues.
    # so unless you need HLS or implement actual multiple var formats, this
    # probably isn't useful.

    # i'm not sure how necessary it is to make the keyframes nice and tidy
    # kind of annoying to have to guess the output framerate.
    # https://superuser.com/questions/908280/what-is-the-correct-way-to-fix-keyframes-in-ffmpeg-for-dash/908325#908325
    #framerate = 30
    #interval = 2
    #keyframes_per_segment = 3

    #opts['r'] = framerate
    #opts['g'] = framerate * interval
    #opts['keyint_min'] = framerate * interval
    #opts['hls_time'] = interval * keyframes_per_segment
    # https://teddit.net/r/ffmpeg/comments/nam6hg/mp4_to_hls_how_to_set_time_segments_properly/
    # not sure if necessary, according to that other superuser post
    # opts['force_key_frames:v'] = 'expr:gte(t,n_forced*2)'
    opts['f'] = 'hls'
    opts['hls_playlist_type'] = 'vod'
    opts['hls_time'] = 10
    opts['hls_list_size'] = 0

    # store chunks in a directory alongside the m3u8 playlist for convenience
    os.makedirs(f"{outfile}.ts", exist_ok=True)
    opts['hls_base_url'] = f"{os.path.basename(outfile)}.ts/"
    opts['hls_segment_filename'] = f"{outfile}.ts/%04d.ts"
else:
    opts['movflags'] = 'faststart'

if args.test:
    # just encode a bit to test
    opts['t'] = 60

audio = ffin[f'a:{audio_track}']

output = ffmpeg.overwrite_output(ffmpeg.output(ffv, audio, outfile, **opts))
print(f"then run {' '.join(output.get_args())=}", file=sys.stderr)

# basic flock queueing for multiple invocations
with open("/tmp/vrcencode", "w+") as f:
    fcntl.flock(f, fcntl.LOCK_EX)
    output.run()

# 2 pass doesn't work that well 
#with tempfile.TemporaryDirectory() as tmpdirname:
#    opts['passlogfile'] = f"{tmpdirname}/passlogfile"
#
#    opts['pass'] = 1
#    pass1 = ffmpeg.output(ffv, audio, "/dev/null", **opts)
#    opts['pass'] = 2
#    pass2 = ffmpeg.output(ffv, audio, outfile, **opts)
#
#    print(f"will run {' '.join(pass1.get_args())=}", file=sys.stderr)
#    print(f"then run {' '.join(pass2.get_args())=}", file=sys.stderr)
#
#    # basic flock queueing for multiple invocations
#    with open("/tmp/vrcencode", "w+") as f:
#        fcntl.flock(f, fcntl.LOCK_EX)
#        pass1.run(overwrite_output=True)
#        pass2.run()
